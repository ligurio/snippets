#!/usr/bin/env python

# Copyright 2018 Sergey Bronnikov
#
# This is free software, licensed under the Apache License, Version 2.0,
# available in the accompanying LICENSE.txt file.

import sys
import subprocess
import optparse
import os

from pycobertura import Cobertura

"""
https://raw.githubusercontent.com/eriwen/lcov-to-cobertura-xml/master/lcov_cobertura/lcov_cobertura.py
https://github.com/jrfonseca/gprof2dot/blob/master/gprof2dot.py
https://github.com/mchalupa/dg
"""

class CallgrindParser():

    def __init__():
        pass


class PerfParser():

    def __init__():
        pass


class CoberturaParser():

    def __init__():
        pass

class GprofParser():

    def __init__():
        pass


class RawParser():

    def __init__():
        pass

formats = {
    "callgrind": CallgrindParser,
    "cobertura": CoberturaParser,
    "perf": PerfParser,
    "prof": GprofParser,
    "raw": RawParser,
}

def resolve_func_name(name, line_num):
    """
    Find function in source code contains specified line.
    The source of data about source code is AST prepared by compiler or
    cppcheck.

    Input: line_num - number of line in source code
    Input: name - name of file with source code
    Output: func_name - name of function contains specified line number
    """
    print(name, line_num)


def process_cobertura(filename):

    cobertura = Cobertura(filename)

    for f in cobertura.files():
	lines = cobertura.hit_statements(f)
	if lines:
	    print f, lines
	    for l in lines:
		resolve_func_name(f, l)

def naturalJoin(values):
    if len(values) >= 2:
        return ', '.join(values[:-1]) + ' or ' + values[-1]

    else:
        return ''.join(values)


def main(argv=None):
    """
    Process coverage data and map tests to coverage functions.

    Usage:
        tt-coverage

    By default, JSON output will be written to stdout.
    """

    formatNames = list(formats.keys())
    formatNames.sort()

    optparser = optparse.OptionParser(
        usage="\n\t%prog [options] [file] ...")
    optparser.add_option(
        '-o', '--output', metavar='FILE',
        type="string", dest="output",
        help="output filename [stdout]")
    optparser.add_option(
        '-i', '--input', metavar='FILE',
        type="string", dest="input",
        help="input filename [stdin]")
    optparser.add_option(
        '-t', '--type',
        type="choice", choices=formatNames,
        dest="type", default="cobertura",
        help="type: %s [default: %%default]" % naturalJoin(formatNames))
    (options, args) = optparser.parse_args(sys.argv[1:])

    if not options.input:
        optparser.error('no input file')

    """
    if len(args) > 1 and options.format != 'pstats':
        optparser.error('incorrect number of arguments')
    """

    """
    if Format.stdinInput:
        if not args:
            fp = sys.stdin
        elif PYTHON_3:
            fp = open(args[0], 'rt', encoding='UTF-8')
        else:
            fp = open(args[0], 'rt')
        parser = Format(fp)
    elif Format.multipleInput:
        if not args:
            optparser.error('at least a file must be specified for %s input' % options.format)
        parser = Format(*args)
    else:
        if len(args) != 1:
            optparser.error('exactly one file must be specified for %s input' % options.format)
        parser = Format(args[0])

    profile = parser.parse()
    """

    """
    if len(args) != 2:
        print(main.__doc__)
        sys.exit(1)
    """

    # TODO: map CLI options to functions
    process_cobertura(options.input)


if __name__ == '__main__':
    main()
